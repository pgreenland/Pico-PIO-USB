
; Copyright (c) 2021 sekigon-gonnoc
; USB FS NRZI receiver
; Run 48 MHz, autopull

.define public IRQ_RX_BS_ERR 1    ; bit stuffing error
.define public IRQ_RX_EOP    2    ; eop detect flag
.define public IRQ_RX_START  3    ; packet start flag

.define BR 5                      ; bit repeat counter (for consequtive ones)

.define db0 0                     ; Debug side-set levels
.define db1 1

; USB receive program run at 12Mhz (LS) or 96MHz (FS)
; shift to left, autopull enable
; pin0: dm
; bit is captured from only dm. For FS dm is still used, but input is inverted.
.program usb_rx

.wrap_target
start:
    wait 1 pin 0 [7]            ; Wait for idle state, then delay till next bit
    wait 0 pin 0                ; Wait for sop bit edge

pin_went_low:
    in null 1                   ; Shift zero into ISR
    set y 4                     ; Load edge timeout, aiming for middle of next bit, 8 cycles (to next expected edge) + 4 cycles (to middle of bit)

pin_low_after_bs:
    set x 5                     ; Reset consequtive ones counter

pin_low:
    jmp pin pin_went_high       ; Jump if the pin is now high
    jmp y-- pin_low             ; Continue monitoring pin while timeout non-zero
    in y 1                      ; Shift one into ISR (jmp y-- will have caused y to wrap to 0xFFFFFFFF)
    set y 1                     ; Load edge timeout, aiming for middle of next bit, 8 cycles (from middle of this bit to middle of next)
    jmp x-- pin_low             ; Decrement consequtive ones counter, continuing if non-zero

pin_low_bs:
    jmp pin pin_high_after_bs   ; Jump if pin high (edge found), skipping storing stuff bit
    jmp y-- pin_low_bs          ; Continue monitoring pin while timeout non-zero
    jmp bs_err                  ; No edge within timeout, bit-stuffing error caught

pin_went_high:
    in null 1                   ; Shift zero into ISR
    set y 4                     ; Load edge timeout, aiming for middle of next bit, 8 cycles (to next expected edge) + 4 cycles (to middle of bit)

pin_high_after_bs:
    set x 5                     ; Reset consequtive ones counter

pin_high:
    jmp pin pin_still_high      ; Jump if the pin is now low (or jump over unconditional jump)
    jmp pin_went_low
pin_still_high:
    jmp y-- pin_high            ; Continue monitoring pin while timeout non-zero
    in y 1                      ; Shift one into ISR (jmp y-- will have caused y to wrap to 0xFFFFFFFF)
    set y 1                     ; Load edge timeout, aiming for middle of next bit, 8 cycles (from middle of this bit to middle of next)
    jmp x-- pin_high            ; Decrement consequtive ones counter, continuing if non-zero

pin_high_bs:
    jmp pin pin_still_high_bs   ; Jump if the pin is now low (or jump over unconditional jump), edge found, skipping storing stuff bit
    jmp pin_low_after_bs
pin_still_high_bs:
    jmp y-- pin_high_bs         ; Continue monitoring pin while timeout non-zero
    ; Fallthrough

bs_err:
    irq wait IRQ_RX_BS_ERR      ; Set bit stuffing error IRQ and wait for host to acknowledge
.wrap


; USB receive program run at 12Mhz (LS) or 96MHz (FS) with debug pin
; shift to left, autopull enable
; pin0: dm
; bit is captured from only dm. For FS dm is still used, but input is inverted.
.program usb_rx_debug
.side_set 1

.wrap_target
start:
    wait 1 pin 0 [7] side db1            ; Wait for idle state, then delay till next bit
    wait 0 pin 0 side db0                ; Wait for sop bit edge

pin_went_low:
    in null 1 side db1                   ; Shift zero into ISR

pin_low_after_bs:
    set y 9 side db0                     ; Load edge timeout, aiming for middle of next bit, 16 cycles (to next expected edge) + 8 cycles (to middle of bit)
    set x 5 side db0                     ; Reset consequtive ones counter

pin_low:
    jmp pin pin_went_high side db0       ; Jump if the pin is now high
    jmp y-- pin_low side db0             ; Continue monitoring pin while timeout non-zero
    in y 1 side db1                      ; Shift one into ISR (jmp y-- will have caused y to wrap to 0xFFFFFFFF)
    set y 5 side db0                     ; Load edge timeout, aiming for middle of next bit, 16 cycles (from middle of this bit to middle of next), subtracting and dividing by instruction execution count
    jmp x-- pin_low side db0             ; Decrement consequtive ones counter, continuing if non-zero

pin_low_bs:
    jmp pin pin_high_after_bs side db0   ; Jump if pin high (edge found), skipping storing stuff bit
    jmp y-- pin_low_bs side db0          ; Continue monitoring pin while timeout non-zero
    jmp bs_err side db0                  ; No edge within timeout, bit-stuffing error caught

pin_went_high:
    in null 1 side db1                   ; Shift zero into ISR

pin_high_after_bs:
    set y 9 side db0                     ; Load edge timeout, aiming for middle of next bit, 16 cycles (to next expected edge) + 4 cycles (to middle of bit), subtracting and dividing by instruction execution count
    set x 5 side db0                     ; Reset consequtive ones counter

pin_high:
    jmp pin pin_still_high side db0      ; Jump if the pin is now low (or jump over unconditional jump)
    jmp pin_went_low side db0
pin_still_high:
    jmp y-- pin_high side db0            ; Continue monitoring pin while timeout non-zero
    in y 1 side db1                      ; Shift one into ISR (jmp y-- will have caused y to wrap to 0xFFFFFFFF)
    set y 5 [1] side db0                     ; Load edge timeout, aiming for middle of next bit, 16 cycles (from middle of this bit to middle of next), subtracting and dividing by instruction execution count
    jmp x-- pin_high side db0            ; Decrement consequtive ones counter, continuing if non-zero

pin_high_bs:
    jmp pin pin_still_high_bs side db0   ; Jump if the pin is now low (or jump over unconditional jump), edge found, skipping storing stuff bit
    jmp pin_low_after_bs side db0
pin_still_high_bs:
    jmp y-- pin_high_bs side db0         ; Continue monitoring pin while timeout non-zero
    ; Fallthrough

bs_err:
    irq wait IRQ_RX_BS_ERR side db0      ; Set bit stuffing error IRQ and wait for host to acknowledge
.wrap

; EOP detect program
; run at 12MHz (LS) and 96Mhz (FS)
; autopull disable
.program eop_detect

.wrap_target
    wait 1 pin 1        ; wait dm is H to avoid catch previous EOP
    wait 0 pin 1
    irq IRQ_RX_START
start:
    set y, 1
    mov isr, null
wait_se0:
    in pins, 2          ; read dp/dm
    mov x, isr
    jmp x-- start       ; check se0
    jmp y-- wait_se0
    irq wait IRQ_RX_EOP ; eop is detected
.wrap

; EOP detect program with debug out
; run at 12MHz (LS) and 96Mhz (FS)
; autopull disable
.program eop_detect_debug
.side_set 1

.wrap_target
    wait 1 pin 1 side db1       ; wait dm is H to avoid catch previous EOP
    wait 0 pin 1 side db1
    irq IRQ_RX_START  side db0
start:
    set y, 1 side db0;
    mov isr, null side db0
wait_se0:
    in pins, 2 side db0         ; read dp/dm
    mov x, isr side db0
    jmp x-- start side db0      ; check se0
    jmp y-- wait_se0 side db0   ;
    irq wait IRQ_RX_EOP side db1         ; eop is detected
.wrap

% c-sdk {
#include "hardware/clocks.h"

  static void __no_inline_not_in_flash_func(usb_rx_configure_pins)(PIO pio, uint sm, uint pin_dp) {
    pio_sm_set_in_pins(pio, sm, pin_dp);
    pio->sm[sm].execctrl = (pio->sm[sm].execctrl & ~PIO_SM0_EXECCTRL_JMP_PIN_BITS) |
                (pin_dp << PIO_SM0_EXECCTRL_JMP_PIN_LSB);
  }

static inline void usb_rx_program_init(PIO pio, uint sm, uint offset, uint pin_dp, bool is_fs, int pin_debug) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin_dp, 2, false);
    gpio_pull_down(pin_dp);
    gpio_pull_down(pin_dp + 1);  // dm

    pio_sm_config c;

    if (pin_debug < 0) {
      c = usb_rx_program_get_default_config(offset);
    } else {
      c = usb_rx_debug_program_get_default_config(offset);

      pio_sm_set_pins_with_mask(pio, sm, 0, 1 << pin_debug);
      pio_sm_set_pindirs_with_mask(pio, sm, 1 << pin_debug, 1 << pin_debug);
      pio_gpio_init(pio, pin_debug);
      sm_config_set_sideset_pins(&c, pin_debug);
    }

    sm_config_set_in_pins(&c, pin_dp + 1);  // for WAIT, IN
    sm_config_set_jmp_pin(&c, pin_dp + 1);  // for JMP

    // Shift to right, autopull enabled, 8bit
    sm_config_set_in_shift(&c, true, true, 8);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    float div;
    if (is_fs) {
        // Run at 96Mhz
        // system clock should be multiple of 12MHz
        div = (float)clock_get_hz(clk_sys) / (96000000);
    } else {
        // Run at 12Mhz
        // system clock should be multiple of 12MHz
        div = (float)clock_get_hz(clk_sys) / (12000000);
    }
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, false);
}

static inline void eop_detect_program_init(PIO pio, uint sm, uint offset, uint pin_dp, bool is_fs, int pin_debug) {
  pio_sm_config c;

  if (pin_debug < 0) {
    c = eop_detect_program_get_default_config(offset);
  } else {
    c = eop_detect_debug_program_get_default_config(offset);
    pio_sm_set_pins_with_mask(pio, sm, 0, 1 << pin_debug);
    pio_sm_set_pindirs_with_mask(pio, sm, 1 << pin_debug, 1 << pin_debug);
    pio_gpio_init(pio, pin_debug);
    sm_config_set_sideset_pins(&c, pin_debug);
  }

  sm_config_set_in_pins(&c, pin_dp);  // for WAIT, IN
  sm_config_set_jmp_pin(&c, pin_dp);  // for JMP

  sm_config_set_in_shift(&c, false, false, 8);

  float div;
  if (is_fs) {
    div = (float)clock_get_hz(clk_sys) / (96000000);
  } else {
    div = (float)clock_get_hz(clk_sys) / (12000000);
  }

  sm_config_set_clkdiv(&c, div);

  pio_sm_init(pio, sm, offset, &c);
  pio_sm_set_enabled(pio, sm, true);
}

%}
